    #include "ClusterMessage.h"
    #include "ClusterCommands.h"
    #include "core/proto/ClusterMessagesProto.pb.h"
    #include <iostream>
    #include <variant>
    #include <vector>

    int ClusterMessage::getClusterId() const {
        return clusterId;
    }

    ClusterCommandType ClusterMessage::getCommandType() const {
        return commandType;
    }

    CommandParamsVariant ClusterMessage::getParams() const {
        return params;
    }

    /*

    ClusterMessage createFillNodeMessage(int clusterId, int nodeId, int color) {
        NodeWithColorParams params;
        params.nodeId = nodeId;
        params.color = color;
        ClusterMessage clusterMessage(clusterId, ClusterCommandType::FillNode, params);
        return clusterMessage;
    }

    ClusterMessage createBlitNodeMessage(int clusterId, int nodeId, std::vector<WRGB> colors, WRGB padColor) {
        BlitNodeParams params;
        params.nodeId = nodeId;
        params.colors = std::move(colors);
        params.padColor = padColor;
        ClusterMessage clusterMessage(clusterId, ClusterCommandType::BlitNode, params);
        return clusterMessage;
    }

    ClusterMessage createSetNodePixelMessage(int clusterId, int nodeId, int color) {
        NodeWithPixelIndexParams params;
        params.nodeId = nodeId;
        params.color = color;
        ClusterMessage clusterMessage(clusterId, ClusterCommandType::SetNodePixel, params);
        return clusterMessage;
    }

    ClusterMessage createQueueNodePixelMessage(int clusterId, int nodeId, int color) {
        NodeWithColorParams params;
        params.nodeId = nodeId;
        params.color = color;
        ClusterMessage clusterMessage(clusterId, ClusterCommandType::QueueNodePixel, params);
        return clusterMessage;
    }

    ClusterMessage createDequeueNodePixelMessage(int clusterId, int nodeId, int color) {
        NodeWithColorParams params;
        params.nodeId = nodeId;
        params.color = color;
        ClusterMessage clusterMessage(clusterId, ClusterCommandType::DequeueNodePixel, params);
        return clusterMessage;
    }
    */

    std::vector<uint8_t> serializeClusterMessage(const ClusterMessage &message) {
        ClusterMessageProto proto_msg = ClusterMessageProto_init_zero;

        // Set fields from your ClusterMessage to proto_msg
        proto_msg.cluster_id = message.getClusterId();
        proto_msg.command_type = static_cast<CommandTypeProto>(message.getCommandType());

        // Extract and set specific command params based params type
        const CommandParamsVariant &paramsVariant = message.getParams();
        if (std::holds_alternative<NodeWithColorParams>(paramsVariant)) {
            const NodeWithColorParams &commandParams = std::get<NodeWithColorParams>(paramsVariant);
            proto_msg.params.node_with_color_params.node_id = commandParams.nodeId;
            proto_msg.params.node_with_color_params.color = commandParams.color;
            proto_msg.which_params = ClusterMessageProto_node_with_color_params_tag;
        } else if (std::holds_alternative<BlitNodeParams>(paramsVariant)) {
            const BlitNodeParams &commandParams = std::get<BlitNodeParams>(paramsVariant);
            proto_msg.params.blit_node_params.node_id = commandParams.nodeId;

            //if (commandParams.colors.size() > MAX_COLORS) {
            //    // Handle error: too many colors
            //}

    // EEEEK THIS IS ALL WRONG!!!
    /*
    no operator "[]" matches these operandsC/C++(349)
    ClusterMessage.cpp(89, 53): operand types are: pb_callback_t [ size_t ]
    ClusterMessage.cpp(89, 53): built-in operator[](<pointer to object>, <ptrdiff_t>) does not match because argument #1 does not match parameter
    ClusterMessage.cpp(89, 53): built-in operator[](<ptrdiff_t>, <pointer to object>) does not match because argument #1 does not match parameter
    pb_callback_t BlitNodeParamsProto::colors
    */
            for (size_t i = 0; i < commandParams.colors.size(); ++i) {
                proto_msg.params.blit_node_params.colors[i] = commandParams.colors[i];
            }

            proto_msg.params.blit_node_params.pad_color = commandParams.padColor;
            proto_msg.which_params = ClusterMessageProto_blit_node_params_tag;
        } else if (std::holds_alternative<NodeWithPixelIndexParams>(paramsVariant)) {
            const NodeWithPixelIndexParams &commandParams = std::get<NodeWithPixelIndexParams>(paramsVariant);
            proto_msg.params.node_with_pixel_index_params.node_id = commandParams.nodeId;
            proto_msg.params.node_with_pixel_index_params.pixel_index = commandParams.pixelIndex;
            proto_msg.params.node_with_pixel_index_params.color = commandParams.color;
            proto_msg.which_params = ClusterMessageProto_node_with_pixel_index_params_tag;
        } else if (std::holds_alternative<FillBufferParams>(paramsVariant)) {
            const FillBufferParams &commandParams = std::get<FillBufferParams>(paramsVariant);
            proto_msg.params.fill_buffer_params.color = commandParams.color;
            proto_msg.which_params = ClusterMessageProto_node_with_color_params_tag;
        } else if (std::holds_alternative<BlitBufferParams>(paramsVariant)) {
            const BlitBufferParams &commandParams = std::get<BlitBufferParams>(paramsVariant);
            proto_msg.params.blit_buffer_params.colors = commandParams.colors;
            proto_msg.params.blit_buffer_params.pad_color = commandParams.padColor;
            proto_msg.which_params = ClusterMessageProto_blit_buffer_tag;
        }

        uint8_t buffer[1024]; // Adjust the buffer size as necessary
        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));

        if (!pb_encode(&stream, ClusterMessageProto_fields, &proto_msg)) {
            std::cout << " ENCODE ERRROR!!! " << std::endl;
        }
        return std::vector<uint8_t>(buffer, buffer + stream.bytes_written);
    }

    ClusterMessage deserializeClusterMessage(const std::vector<uint8_t> &buffer) {
        ClusterMessageProto proto_msg = ClusterMessageProto_init_zero;
        pb_istream_t stream = pb_istream_from_buffer(buffer.data(), buffer.size());

        if (!pb_decode(&stream, ClusterMessageProto_fields, &proto_msg)) {
            std::cout << "DECODING ERROR" << std::endl;
            // Handle decoding error
        }

        CommandParamsVariant params;
        // Handle the specific command parameters based on the command type
        if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_FILL_NODE) {
            NodeWithColorParams commandParams;
            commandParams.nodeId = proto_msg.params.node_with_color_params.node_id;
            commandParams.color = proto_msg.params.node_with_color_params.color;
            params = commandParams;
        } else if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_BLIT_NODE) {
        } else if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_FILL_BUFFER) {
        } else if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_BLIT_BUFFER) {
        } else if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_SET_NODE_PIXEL) {
        } else if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_QUEUE_NODE_PIXEL) {
        } else if (proto_msg.command_type == CommandTypeProto::CommandTypeProto_DEQUEUE_NODE_PIXEL) {
        } else {
            std::cout << "proto fails to match type" << std::endl;
        }

        if (std::holds_alternative<NodeWithColorParams>(params)) {
            // Step 3: Extract NodeWithColorParams
            NodeWithColorParams castedParams = std::get<NodeWithColorParams>(params);
        }
        ClusterMessage message(proto_msg.cluster_id, static_cast<ClusterCommandType>(proto_msg.command_type), params);

        return message;
    }

    // Function to execute the command contained within a ClusterMessage
    void executeMessageCommand(const ClusterMessage &clusterMessage, Cluster &cluster) {
        switch (clusterMessage.getCommandType()) {
        case ClusterCommandType::FillNode: {
            auto params = std::get<NodeWithColorParams>(clusterMessage.getParams());
            FillNodeCommand command(params.nodeId, params.color);
            command.execute(cluster);
            break;
        }
        case ClusterCommandType::BlitNode: {
            auto params = std::get<BlitNodeParams>(clusterMessage.getParams());
            BlitNodeCommand command(params.nodeId, params.colors, params.padColor);
            command.execute(cluster);
            break;
        }
        case ClusterCommandType::SetNodePixel: {
            auto params = std::get<NodeWithPixelIndexParams>(clusterMessage.getParams());
            SetNodePixelCommand command(params.nodeId, params.pixelIndex, params.color);
            command.execute(cluster);
            break;
        }
        case ClusterCommandType::QueueNodePixel: {
            auto params = std::get<NodeWithColorParams>(clusterMessage.getParams());
            QueueNodePixelCommand command(params.nodeId, params.color);
            // Assuming you have a mechanism to handle or ignore the return value
            command.execute(cluster);
            break;
        }
        case ClusterCommandType::DequeueNodePixel: {
            auto params = std::get<NodeWithColorParams>(clusterMessage.getParams());
            DequeueNodePixelCommand command(params.nodeId, params.color);
            // Assuming you have a mechanism to handle or ignore the return value
            command.execute(cluster);
            break;
        }
        case ClusterCommandType::FillBuffer: {
            auto params = std::get<FillBufferParams>(clusterMessage.getParams());
            FillBufferCommand command(params.color);
            command.execute(cluster);
            break;
        }
        case ClusterCommandType::BlitBuffer: {
            auto params = std::get<BlitBufferParams>(clusterMessage.getParams());
            BlitBufferCommand command(params.colors, params.padColor);
            command.execute(cluster);
            break;
        }
        default:
            // Handle unknown command type, perhaps log an error
            break;
        }
    }
